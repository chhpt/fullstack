# 模块

## 模块的实现

在 Node 中引入模块，需要经历 3 个阶段：

- 路径分析
- 文件定位
- 编译执行

在 Node 中，模块主要分为两类，一类是 Node 提供的模块，称为核心模块，另一类是用户编写的模块，称为文件模块。

### 优先从缓存加载

Node 对引入过的模块都会进行缓存，以减少二次引入时的开销，Node 缓存的是编译和执行之后的对象。不论是核心模块还是文件模块，require() 方法对相同模块的二次加载都遵循缓存优先的原则。

### 路径分析

基于 require() 方法接受的标识符进行分析，模块标识符主要分类以下几类：

- 核心模块， http, fs, path 等
- `.` 或 `..` 开始的相对路径文件
- `/` 开始的绝对路径文件
- 非路径形式的文件模块，如自定义的 connect 模块

#### 核心模块

用户无法加载一个与核心模块同名的自定义模块，除非选择一个不同的标识符或者换用路径。

#### 文件模块

以 `.` 、`..` 和 `/` 开始的标识符，都会被当做文件模块来处理。在分析模块的路径时，require() 方法会将路径转化为真实路径，并以真实路径作为索引，将编译执行后的结果存放到缓存中。

#### 自定义模块

自定义模块指的是非核心模块，也不是路径形式的标识符。它是一种特殊的文件模块，可能是一个文件或者包的形式。在加载过程中，Node 会逐个尝试模块路径中的路径，直到找到目标文件为止。

> **模块路径**
> 模块路径是 Node 在定位文件模块的具体文件时定制的查找策略，表现为一个由路径组成的数组。如 Linux 下可能是这样的：
> ['/Users/test/Desktop/project/node_modules',
> '/Users/test/Desktop/node_modules',
> '/Users/test/node_modules',
> '/Users/node_modules',
> '/node_modules' ]

### 文件定位

#### 文件扩展名分析

require() 在分析标识符的时候，会出现标识符中不包含文件扩展名的情况，这时， Node 会按 `.js` ，`.node`， `.json` 的次序补足扩展名，依次尝试。

在尝试的过程中，需要调用 fs 模块同步阻塞式地判断文件是否存在。因为 Node 是单线程的， 所以这里是一个会引起性能问题的地方。有一个小诀窍：如果是 `.node` 和 `.json` 文件，在传递给 require() 的标识符中带上扩展名，会加快一点速度。

#### 目录分析和包

在分析标识符的过程中，require() 通过分析文件扩展名之后，可能没有查找到对应文件，但却得到一个目录，这在引入自定义模块和逐个模块路径进行查找时经常会出现，此时 Node 会将这个目录当做一个包来处理。

然后， Node 在当前目录（查找到的包目录）下查找 package.json，通过 JSON.parse() 解析出包描述对象，从中取出 main 属性指定的文件名进行定位。如果文件名缺少扩展名，将会进入扩展名分析的步骤。

而如果 main 属性指定的文件名错误，或者压根没有 package.json 文件，Node 会将 index 当做默认文件名，然后依次查找 index.js、index.node、index.json。

如果在目录分析的过程中没有定位成功任何文件，则自定义模块进入下一个模块路径进行查找。如果模块路径数组都被遍历完毕，依然没有查找到目标文件，则会抛出查找失败的异常。

### 编译执行

编译和执行是引入文件模块的最后一个阶段。定位到具体的文件后，Node 会新建一个模块对象，然后根据路径载入并编译。对于不同的文件扩展名，其载入方法也有所不同，具体如下所示。

- `.js` 文件。通过 fs 模块同步读取文件后编译执行。
- `.node` 文件。这是用 C/C++ 编写的扩展文件，通过 `dlopen()` 方法加载最后编译生成的文件。
- `.json` 文件。通过 fs 模块同步读取文件后，用 `JSON.parse()` 解析返回结果。
- 其余扩展名文件。它们都被当做 `.js` 文件载入。 每一个编译成功的模块都会将其文件路径作为索引缓存在 `Module._cache` 对象上，以提高二 次引入的性能。

#### JavaScript 模块的编译

我们知道每个模块文件中存在着 require、exports、module 这 3 个变量，但是它们在模块文件中并没有定义，那么从何而来呢？甚至在 Node 的 API 文档中，我们 道每个模块中还有 `__filename` 、`__dirname` 这两个变量的存在，它们又是从何而来的呢？

事实上，在编译的过程中，Node 对获取的 JavaScript 文件内容进行了头尾包装。在头部添加 了 `(function (exports, require, module, __filename, __dirname) {\n`，在尾部添加了 `\n});`。 一个正常的 JavaScript 文件会被包装成如下的样子：

```JavaScript
(function(exports, require, module, __filename, __dirname) { // 添加
  var math = require('math');
  exports.area = function(radius) {
    return Math.PI * radius * radius;
  };
}); // 添加
```

这样每个模块文件之间都进行了作用域隔离。包装之后的代码会通过 vm 原生模块的 runInThisContext() 方法执行（类似 eval，只是具有明确上下文，不污染全局），返回一个具体的 `function 对象`。最后，将当前模块对象的 exports 属性、require() 方法、module（模块对象自身），以及在文件定位中得到的完整文件路径和文件目录作为参数传递给这个 `function()` 执行。

这就是这些变量并没有定义在每个模块文件中却存在的原因。在执行之后，模块的 exports 属性被返回给了调用方。exports 属性上的任何方法和属性都可以被外部调用到，但是模块中的其余变量或属性则不可直接被调用。

#### 关于 exports 和 module.exports

此外，许多初学者都曾经纠结过为何存在 exports 的情况下，还存在 module.exports。理想情 况下，只要赋值给 exports 即可：

```JavaScript
exports = function () {};
```

但是通常都会得到一个失败的结果。其原因在于，exports 对象是通过形参的方式传入的，直接赋值形参会改变形参的引用，但并不能改变作用域外的值。如果要达到 require 引入一个类的效果，请赋值给 module.exports 对象，这个迂回的方案不改变形参的引用。

```JavaScript
module.exports = function () {};
```
