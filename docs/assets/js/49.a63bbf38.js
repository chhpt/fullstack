(window.webpackJsonp=window.webpackJsonp||[]).push([[49],{378:function(t,a,e){"use strict";e.r(a);var r=e(5),s=Object(r.a)({},function(){var t=this,a=t.$createElement,e=t._self._c||a;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("h1",{attrs:{id:"浏览器渲染"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#浏览器渲染","aria-hidden":"true"}},[t._v("#")]),t._v(" 浏览器渲染")]),t._v(" "),e("h2",{attrs:{id:"预解析"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#预解析","aria-hidden":"true"}},[t._v("#")]),t._v(" 预解析")]),t._v(" "),e("p",[t._v("WebKit 和 Firefox 都进行了这项优化。在执行脚本时，其他线程会解析文档的其余部分，找出并加载需要通过网络加载的其他资源。通过这种方式，资源可以在并行连接上加载，从而提高总体速度。请注意，预解析器不会修改 DOM 树，而是将这项工作交由主解析器处理；预解析器只会解析外部资源（例如外部脚本、样式表和图片）的引用。")]),t._v(" "),e("h2",{attrs:{id:"js-文件"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#js-文件","aria-hidden":"true"}},[t._v("#")]),t._v(" JS 文件")]),t._v(" "),e("p",[t._v("解析器遇到 "),e("code",[t._v("<script>")]),t._v(" 标记时立即解析并执行脚本，文档的解析将停止，直到脚本执行完毕。如果脚本是外部的，那么解析过程会停止，直到从网络同步抓取资源完成后再继续。此模型已经使用了多年，也在 HTML4 和 HTML5 规范中进行了指定。作者也可以将脚本标注为 "),e("code",[t._v("defer")]),t._v("，这样它就不会停止文档解析，而是等到解析结束才执行。HTML5 增加了一个选项，可将脚本标记为异步 "),e("code",[t._v("async")]),t._v("，以便由其他线程解析和执行。")]),t._v(" "),e("h2",{attrs:{id:"css-文件"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#css-文件","aria-hidden":"true"}},[t._v("#")]),t._v(" CSS 文件")]),t._v(" "),e("p",[t._v("通常情况下，CSS 解析不会影响页面的结构，因为 CSS 解析不会阻塞页面的解析，但是 CSS 解析会阻塞页面的渲染，只有当 CSS 解析完成后，才能继续完成页面渲染。理论上来说，应用样式表不会更改 DOM 树，因此似乎没有必要等待样式表并停止文档解析。但这涉及到一个问题，就是脚本在文档解析阶段会请求样式信息。如果当时还没有加载和解析样式，脚本就会获得错误的回复，这样显然会产生很多问题。Firefox 在样式表加载和解析的过程中，会禁止所有脚本。而对于 WebKit 而言，仅当脚本尝试访问的样式属性可能受尚未加载的样式表影响时，它才会禁止该脚本。")]),t._v(" "),e("h2",{attrs:{id:"总结"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#总结","aria-hidden":"true"}},[t._v("#")]),t._v(" 总结")]),t._v(" "),e("ul",[e("li",[t._v("CSS 不会阻塞 DOM 的解析，但会阻塞 DOM 渲染。")]),t._v(" "),e("li",[t._v('JS 阻塞 DOM 解析，但浏览器会"偷看"DOM，预先下载相关资源。')]),t._v(" "),e("li",[t._v("浏览器遇到 "),e("code",[t._v("<script>")]),t._v(" 且没有 "),e("code",[t._v("defer")]),t._v(" 或 "),e("code",[t._v("async")]),t._v(" 属性的标签时，会触发页面渲染，因而如果前面 CSS 资源尚未加载完毕时，浏览器会等待它加载完毕再执行脚本。")])])])},[],!1,null,null,null);a.default=s.exports}}]);